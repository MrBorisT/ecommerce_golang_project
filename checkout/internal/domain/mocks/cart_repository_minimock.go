package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.CartRepository -o ./mocks/cart_repository_minimock.go -n CartRepositoryMock

import (
	"context"
	"route256/checkout/internal/repository/schema"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements domain.CartRepository
type CartRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartRepositoryMockAddToCart

	funcDeleteFromCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCartRepositoryMockDeleteFromCart

	funcListCart          func(ctx context.Context, user int64) (ca1 []schema.CartItems, err error)
	inspectFuncListCart   func(ctx context.Context, user int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mCartRepositoryMockListCart

	funcPurchase          func(ctx context.Context, user int64) (err error)
	inspectFuncPurchase   func(ctx context.Context, user int64)
	afterPurchaseCounter  uint64
	beforePurchaseCounter uint64
	PurchaseMock          mCartRepositoryMockPurchase
}

// NewCartRepositoryMock returns a mock for domain.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartRepositoryMockAddToCartParams{}

	m.DeleteFromCartMock = mCartRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CartRepositoryMockDeleteFromCartParams{}

	m.ListCartMock = mCartRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*CartRepositoryMockListCartParams{}

	m.PurchaseMock = mCartRepositoryMockPurchase{mock: m}
	m.PurchaseMock.callArgs = []*CartRepositoryMockPurchaseParams{}

	return m
}

type mCartRepositoryMockAddToCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddToCartExpectation
	expectations       []*CartRepositoryMockAddToCartExpectation

	callArgs []*CartRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockAddToCartExpectation specifies expectation struct of the CartRepository.AddToCart
type CartRepositoryMockAddToCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockAddToCartParams
	results *CartRepositoryMockAddToCartResults
	Counter uint64
}

// CartRepositoryMockAddToCartParams contains parameters of the CartRepository.AddToCart
type CartRepositoryMockAddToCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepositoryMockAddToCartResults contains results of the CartRepository.AddToCart
type CartRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartRepositoryMockAddToCartParams{ctx, user, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Return(err error) *CartRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartRepository.AddToCart method
func (mmAddToCart *mCartRepositoryMockAddToCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartRepositoryMockAddToCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartRepositoryMockAddToCartParams{ctx, user, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddToCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements domain.CartRepository
func (mmAddToCart *CartRepositoryMock) AddToCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, user, sku, count)
	}

	mm_params := &CartRepositoryMockAddToCartParams{ctx, user, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockAddToCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, user, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddToCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartRepositoryMockAddToCart) Calls() []*CartRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.AddToCart")
	}
}

type mCartRepositoryMockDeleteFromCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteFromCartExpectation
	expectations       []*CartRepositoryMockDeleteFromCartExpectation

	callArgs []*CartRepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockDeleteFromCartExpectation specifies expectation struct of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockDeleteFromCartParams
	results *CartRepositoryMockDeleteFromCartResults
	Counter uint64
}

// CartRepositoryMockDeleteFromCartParams contains parameters of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepositoryMockDeleteFromCartResults contains results of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CartRepositoryMockDeleteFromCartParams{ctx, user, sku, count}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Return(err error) *CartRepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CartRepositoryMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteFromCart method
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CartRepository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CartRepositoryMockDeleteFromCartParams{ctx, user, sku, count},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteFromCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements domain.CartRepository
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, user, sku, count)
	}

	mm_params := &CartRepositoryMockDeleteFromCartParams{ctx, user, sku, count}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockDeleteFromCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CartRepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, user, sku, count)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteFromCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CartRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CartRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Calls() []*CartRepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteFromCart")
	}
}

type mCartRepositoryMockListCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockListCartExpectation
	expectations       []*CartRepositoryMockListCartExpectation

	callArgs []*CartRepositoryMockListCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockListCartExpectation specifies expectation struct of the CartRepository.ListCart
type CartRepositoryMockListCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockListCartParams
	results *CartRepositoryMockListCartResults
	Counter uint64
}

// CartRepositoryMockListCartParams contains parameters of the CartRepository.ListCart
type CartRepositoryMockListCartParams struct {
	ctx  context.Context
	user int64
}

// CartRepositoryMockListCartResults contains results of the CartRepository.ListCart
type CartRepositoryMockListCartResults struct {
	ca1 []schema.CartItems
	err error
}

// Expect sets up expected params for CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Expect(ctx context.Context, user int64) *mCartRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &CartRepositoryMockListCartParams{ctx, user}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Inspect(f func(ctx context.Context, user int64)) *mCartRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Return(ca1 []schema.CartItems, err error) *CartRepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &CartRepositoryMockListCartResults{ca1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the CartRepository.ListCart method
func (mmListCart *mCartRepositoryMockListCart) Set(f func(ctx context.Context, user int64) (ca1 []schema.CartItems, err error)) *CartRepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the CartRepository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mCartRepositoryMockListCart) When(ctx context.Context, user int64) *CartRepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &CartRepositoryMockListCartParams{ctx, user},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ListCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListCartExpectation) Then(ca1 []schema.CartItems, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockListCartResults{ca1, err}
	return e.mock
}

// ListCart implements domain.CartRepository
func (mmListCart *CartRepositoryMock) ListCart(ctx context.Context, user int64) (ca1 []schema.CartItems, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, user)
	}

	mm_params := &CartRepositoryMockListCartParams{ctx, user}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockListCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("CartRepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the CartRepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, user)
	}
	mmListCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListCart. %v %v", ctx, user)
	return
}

// ListCartAfterCounter returns a count of finished CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mCartRepositoryMockListCart) Calls() []*CartRepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ListCart")
	}
}

type mCartRepositoryMockPurchase struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockPurchaseExpectation
	expectations       []*CartRepositoryMockPurchaseExpectation

	callArgs []*CartRepositoryMockPurchaseParams
	mutex    sync.RWMutex
}

// CartRepositoryMockPurchaseExpectation specifies expectation struct of the CartRepository.Purchase
type CartRepositoryMockPurchaseExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockPurchaseParams
	results *CartRepositoryMockPurchaseResults
	Counter uint64
}

// CartRepositoryMockPurchaseParams contains parameters of the CartRepository.Purchase
type CartRepositoryMockPurchaseParams struct {
	ctx  context.Context
	user int64
}

// CartRepositoryMockPurchaseResults contains results of the CartRepository.Purchase
type CartRepositoryMockPurchaseResults struct {
	err error
}

// Expect sets up expected params for CartRepository.Purchase
func (mmPurchase *mCartRepositoryMockPurchase) Expect(ctx context.Context, user int64) *mCartRepositoryMockPurchase {
	if mmPurchase.mock.funcPurchase != nil {
		mmPurchase.mock.t.Fatalf("CartRepositoryMock.Purchase mock is already set by Set")
	}

	if mmPurchase.defaultExpectation == nil {
		mmPurchase.defaultExpectation = &CartRepositoryMockPurchaseExpectation{}
	}

	mmPurchase.defaultExpectation.params = &CartRepositoryMockPurchaseParams{ctx, user}
	for _, e := range mmPurchase.expectations {
		if minimock.Equal(e.params, mmPurchase.defaultExpectation.params) {
			mmPurchase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurchase.defaultExpectation.params)
		}
	}

	return mmPurchase
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.Purchase
func (mmPurchase *mCartRepositoryMockPurchase) Inspect(f func(ctx context.Context, user int64)) *mCartRepositoryMockPurchase {
	if mmPurchase.mock.inspectFuncPurchase != nil {
		mmPurchase.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.Purchase")
	}

	mmPurchase.mock.inspectFuncPurchase = f

	return mmPurchase
}

// Return sets up results that will be returned by CartRepository.Purchase
func (mmPurchase *mCartRepositoryMockPurchase) Return(err error) *CartRepositoryMock {
	if mmPurchase.mock.funcPurchase != nil {
		mmPurchase.mock.t.Fatalf("CartRepositoryMock.Purchase mock is already set by Set")
	}

	if mmPurchase.defaultExpectation == nil {
		mmPurchase.defaultExpectation = &CartRepositoryMockPurchaseExpectation{mock: mmPurchase.mock}
	}
	mmPurchase.defaultExpectation.results = &CartRepositoryMockPurchaseResults{err}
	return mmPurchase.mock
}

// Set uses given function f to mock the CartRepository.Purchase method
func (mmPurchase *mCartRepositoryMockPurchase) Set(f func(ctx context.Context, user int64) (err error)) *CartRepositoryMock {
	if mmPurchase.defaultExpectation != nil {
		mmPurchase.mock.t.Fatalf("Default expectation is already set for the CartRepository.Purchase method")
	}

	if len(mmPurchase.expectations) > 0 {
		mmPurchase.mock.t.Fatalf("Some expectations are already set for the CartRepository.Purchase method")
	}

	mmPurchase.mock.funcPurchase = f
	return mmPurchase.mock
}

// When sets expectation for the CartRepository.Purchase which will trigger the result defined by the following
// Then helper
func (mmPurchase *mCartRepositoryMockPurchase) When(ctx context.Context, user int64) *CartRepositoryMockPurchaseExpectation {
	if mmPurchase.mock.funcPurchase != nil {
		mmPurchase.mock.t.Fatalf("CartRepositoryMock.Purchase mock is already set by Set")
	}

	expectation := &CartRepositoryMockPurchaseExpectation{
		mock:   mmPurchase.mock,
		params: &CartRepositoryMockPurchaseParams{ctx, user},
	}
	mmPurchase.expectations = append(mmPurchase.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.Purchase return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockPurchaseExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockPurchaseResults{err}
	return e.mock
}

// Purchase implements domain.CartRepository
func (mmPurchase *CartRepositoryMock) Purchase(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmPurchase.beforePurchaseCounter, 1)
	defer mm_atomic.AddUint64(&mmPurchase.afterPurchaseCounter, 1)

	if mmPurchase.inspectFuncPurchase != nil {
		mmPurchase.inspectFuncPurchase(ctx, user)
	}

	mm_params := &CartRepositoryMockPurchaseParams{ctx, user}

	// Record call args
	mmPurchase.PurchaseMock.mutex.Lock()
	mmPurchase.PurchaseMock.callArgs = append(mmPurchase.PurchaseMock.callArgs, mm_params)
	mmPurchase.PurchaseMock.mutex.Unlock()

	for _, e := range mmPurchase.PurchaseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurchase.PurchaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurchase.PurchaseMock.defaultExpectation.Counter, 1)
		mm_want := mmPurchase.PurchaseMock.defaultExpectation.params
		mm_got := CartRepositoryMockPurchaseParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurchase.t.Errorf("CartRepositoryMock.Purchase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurchase.PurchaseMock.defaultExpectation.results
		if mm_results == nil {
			mmPurchase.t.Fatal("No results are set for the CartRepositoryMock.Purchase")
		}
		return (*mm_results).err
	}
	if mmPurchase.funcPurchase != nil {
		return mmPurchase.funcPurchase(ctx, user)
	}
	mmPurchase.t.Fatalf("Unexpected call to CartRepositoryMock.Purchase. %v %v", ctx, user)
	return
}

// PurchaseAfterCounter returns a count of finished CartRepositoryMock.Purchase invocations
func (mmPurchase *CartRepositoryMock) PurchaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurchase.afterPurchaseCounter)
}

// PurchaseBeforeCounter returns a count of CartRepositoryMock.Purchase invocations
func (mmPurchase *CartRepositoryMock) PurchaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurchase.beforePurchaseCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.Purchase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurchase *mCartRepositoryMockPurchase) Calls() []*CartRepositoryMockPurchaseParams {
	mmPurchase.mutex.RLock()

	argCopy := make([]*CartRepositoryMockPurchaseParams, len(mmPurchase.callArgs))
	copy(argCopy, mmPurchase.callArgs)

	mmPurchase.mutex.RUnlock()

	return argCopy
}

// MinimockPurchaseDone returns true if the count of the Purchase invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockPurchaseDone() bool {
	for _, e := range m.PurchaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurchaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurchaseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurchase != nil && mm_atomic.LoadUint64(&m.afterPurchaseCounter) < 1 {
		return false
	}
	return true
}

// MinimockPurchaseInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockPurchaseInspect() {
	for _, e := range m.PurchaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.Purchase with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurchaseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurchaseCounter) < 1 {
		if m.PurchaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.Purchase")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.Purchase with params: %#v", *m.PurchaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurchase != nil && mm_atomic.LoadUint64(&m.afterPurchaseCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.Purchase")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockListCartInspect()

		m.MinimockPurchaseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockListCartDone() &&
		m.MinimockPurchaseDone()
}
